/*
 * Program to implement a SAT solver using the DPLL algorithm with unit
 * propagation Sukrut Rao CS15BTECH11036
 */

#include <algorithm>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <string>
#include <vector>

#include <stdio.h>
#include <stdint.h>
#include "platform.h"
#include "xil_printf.h"

#define reg0 (volatile uint32_t *) 0x43C00000
#define reg1 (volatile uint32_t *) 0x43C00004
#define reg2 (volatile uint32_t *) 0x43C00008
#define reg3 (volatile uint32_t *) 0x43C0000c
#define reg4 (volatile uint32_t *) 0x43C00010
#define reg5 (volatile uint32_t *) 0x43C00014
#define reg6 (volatile uint32_t *) 0x43C00018

using namespace std;
using namespace std::chrono;


/*
 * enum for different types of return flags defined
 */
enum Cat {
    satisfied,    // when a satisfying assignment has been found
    unsatisfied,  // when no satisfying assignment has been found after
                  // exhaustively searching
    normal,       // when no satisfying assignment has been found till now, and
                  // DPLL() has exited normally
    completed     // when the DPLL algorithm has completed execution
};

/*
 * class to represent a boolean formula
 */
class Formula {
   public:
    // a vector that stores the value assigned to each variable, where
    // -1 - unassigned
    // 0 - true
    // 1 - false
    vector<int> literals;
    vector<int> literal_frequency;  // vector to store the number of occurrences
                                    // of each literal

    // vector to store the difference in number of occurrences with
    // positive and negative polarity of each literal
    vector<int> literal_polarity;

    // vector to store the clauses
    // for each clauses, if the variable n is of positive polarity, then 2n is
    // stored if the variable n is of negative polarity, then 2n+1 is stored
    // here, n is assumed to be zero indexed
    vector<vector<int>> clauses;
    Formula() {}

    // copy constructor for copying a formula - each member is copied over
    Formula(const Formula &f) {
        literals = f.literals;
        clauses = f.clauses;
        literal_frequency = f.literal_frequency;
        literal_polarity = f.literal_polarity;
    }
};

/*
 * class to represent the structure and functions of the SAT Solver
 */
class SATSolverDPLL {
   private:
    Formula formula;                     // the initial formula given as input
    int literal_count;                   // the number of variables in the formula
    int clause_count;                    // the number of clauses in the formula
    int unit_propagate(Formula &, int, bool);  // performs unit propagation
    int DPLL(Formula);                   // performs DPLL recursively
    int apply_transform(
        Formula &,
        int);                          // applies the value of the literal in every clause
    void show_result(Formula &, int);  // displays the result
   public:
    SATSolverDPLL() {}
    void SendClausesToAccelerator();
    void initialize();  // intiializes the values
    void solve();       // calls the solver
};

void SATSolverDPLL::SendClausesToAccelerator(){
	for (int i = 0; i < clause_count; i++) {
		int var1 = formula.clauses[i][0];
		int var2 = formula.clauses[i][1];
		int var3 = formula.clauses[i][2];

		int var1_id = var1/2 + 1;
		int var1_polarity = (var1+1)%2; // In HW: True if 1, False if 0. In SW: True if 0, False if 1

		int var2_id = var2/2 + 1;
		int var2_polarity = (var2+1)%2;

		int var3_id = var3/2 + 1;
		int var3_polarity = (var3+1)%2;

		*reg1 = (var1_id << 1) | var1_polarity;
		*reg2 = (var2_id << 1) | var2_polarity;
		*reg3 = (var3_id << 1) | var3_polarity;
		*reg0 = (i << 1)|1;

		while(*reg4 == 0){
		}

		if(*reg4==1){
			printf("Updated Clause\n");
			*reg4 = 0;
		}
	}

	// For each clause:
	// 1. Write variable 1 + polarity to reg1
	// 2. Write variable 2 + polarity to reg2
	// 3. Write variable 3 + polarity to reg3
	// 4. Write cpu OP code 01 with clause id to reg1
	// 5. Listen to reg4 for complete signal

}

/*
 * function that accepts the inputs from the user and initializes the attributes
 * in the solver
 */
void SATSolverDPLL::initialize() {
    char c;    // store first character
    string s;  // dummy string

    while (true) {
        cin >> c;
        if (c == 'c')  // if comment
        {
            getline(cin, s);  // ignore
        } else                // else, if would be a p
        {
            cin >> s;  // this would be cnf
            break;
        }
    }
    cin >> literal_count;
    cin >> clause_count;

    // set the vectors to their appropriate sizes and initial values
    formula.literals.clear();
    formula.literals.resize(literal_count, -1);
    formula.clauses.clear();
    formula.clauses.resize(clause_count);
    formula.literal_frequency.clear();
    formula.literal_frequency.resize(literal_count, 0);
    formula.literal_polarity.clear();
    formula.literal_polarity.resize(literal_count, 0);

    int literal;  // store the incoming literal value iterate over the clauses
    for (int i = 0; i < clause_count; i++) {
        while (true)  // while the ith clause gets more literals
        {
            cin >> literal;
            if (literal > 0) {                                    // if the variable has positive polarity
                formula.clauses[i].push_back(2 * (literal - 1));  // store it in the form 2n
                // increment frequency and polarity of the literal
                formula.literal_frequency[literal - 1]++;
                formula.literal_polarity[literal - 1]++;
            } else if (literal < 0) {                                        // if the variable has negative polarity
                formula.clauses[i].push_back(2 * ((-1) * literal - 1) + 1);  // store it in the form 2n+1 increment frequency and decrement polarity of the literal
                formula.literal_frequency[-1 - literal]++;
                formula.literal_polarity[-1 - literal]--;
            } else {
                break;  // read 0, so move to next clause
            }
        }
    }
    SendClausesToAccelerator();
}

/*
 * function to perform unit resolution in a given formula
 * arguments: f - the formula to perform unit resolution on
 * return value: int - the status of the solver after unit resolution, a member
 * of the Cat enum Cat::satisfied - the formula has been satisfied
 *               Cat::unsatisfied - the formula can no longer be satisfied
 *               Cat::normal - normal exit
 */
int SATSolverDPLL::unit_propagate(Formula &f, int literal_to_apply, bool use_literal) {
    int value_to_apply = f.literals[literal_to_apply];  // the value to apply, 0 - if true, 1 - if false

    cout << "Applying literal: " << literal_to_apply << endl;

    int decision_id = literal_to_apply + 1;
	int decision_polarity = (value_to_apply+1)%2; // True if 1, False if 0

	int decision = decision_id << 1 | decision_polarity;
	// Send decision to FPGA
	*reg1 = decision;
	*reg0 = 2;
	std::vector<int> assignmentsInThisLevel;
	assignmentsInThisLevel.push_back(decision);
	while(*reg4 == 0){
		// Wait
	}

	while(*reg4 != 0){
		volatile int status = *reg4;
		switch(status){
			case 1:
			{
				// Check Reg 6. If not 0 add to f.
				bool isImpl = false;
				while(*reg6 == 6){
					isImpl = true;
					int implication = *reg5;
					assignmentsInThisLevel.push_back(implication);

					int implication_id = (implication >> 1) - 1;
					int implication_polarity = (~implication) & 1; // In Accelerator, 1 = positive, 0 = negative. SW the logic is reversed.

					f.literals[implication_id] = implication_polarity;  // 0 - if true, 1 - if false, set the literal
					f.literal_frequency[implication_id] = -1;

					cout << "Unit Implication" << implication_id<< "\n";
				}// Need to check if satisfied after all the unit implications
				if(!isImpl){
					return Cat::normal;
				}

				*reg4 = 0;
				break;
			}
			case 4:
				// Conflict, Start backtracking. Pop each assignment in queue.
				while (!assignmentsInThisLevel.empty()){
			    	int backtrack=assignmentsInThisLevel.back();
			    	assignmentsInThisLevel.pop_back();

			    	*reg1 = backtrack;
			    	*reg0 = 3;

			    	while(*reg4 == 0){
			    		// Wait
			    	}

			    	if(*reg4 == 1){
			    		cout << "Backtracked " << backtrack << "\n";
			    	}else{
			    		cout << "Backtrack error, status code:" << *reg4 << "\n";
			    	}
				}
				*reg4 = 0;
				return Cat::unsatisfied;
				break;
			case 5:
				// SAT, output assignments
				return Cat::satisfied;
				break;
			default:
				*reg4 = 0;
				return Cat::unsatisfied;
				// Error state
		}
	}

    return Cat::normal;  // if reached here, the unit resolution ended normally
}

/*
 * applies a value of a literal to all clauses in a given formula
 * arguments: f - the formula to apply on
 *            literal_to_apply - the literal which has just been set
 * return value: int - the return status flag, a member of the Cat enum
 *               Cat::satisfied - the formula has been satisfied
 *               Cat::unsatisfied - the formula can no longer be satisfied
 *               Cat::normal - normal exit
 */
//int SATSolverDPLL::apply_transform(Formula &f, int literal_to_apply) {
//    int value_to_apply = f.literals[literal_to_apply];  // the value to apply, 0 - if true, 1 - if false iterate over the clauses in f
//
//    int decision_id = value_to_apply/2 + 1;
//	int decision_polarity = value_to_apply%2; // True if 0, False if 1
//
//	int decision = decision_id << 1 | decision_polarity;
//	// Send decision to FPGA
//	*reg1 = decision;
//	*reg0 = 1;
//	std::vector<int> assignmentsInThisLevel;
//	assignmentsInThisLevel.push_back(decision);
//	while(*reg4 == 0){
//		// Wait
//	}
//
//	int status = *reg4;
//
//	switch(status){
//		case 1:
//			// Move on to next decision
//			break;
//		case 4:
//			// Conflict, Start backtracking. Pop each assignment in queue.
//			while (!assignmentsInThisLevel.empty())
//			  {
//			    int backtrack=assignmentsInThisLevel.back();
//			    assignmentsInThisLevel.pop_back();
//
//			    *reg1 = backtrack;
//			    *reg0 = 3;
//
//			    while(*reg4 == 0){
//			    		// Wait
//			    }
//
//			    if(*reg4 == 1){
//			    	cout << "Backtracked " << backtrack << "\n";
//			    }
//			  }
//			return Cat::unsatisfied;
//			break;
//		case 5:
//			// SAT, output assignments
//			return Cat::satisfied;
//			break;
//		case 6:
//			// Implication, add implication to queue
//			while(*reg4 == 6){
//				int implication = *reg5;
//				assignmentsInThisLevel.push_back(implication);
//
//				int implication_id = implication >> 1 - 1;
//				int implication_polarity = (~implication) & 1; // In Accelerator, 1 = positive, 0 = negative. SW the logic is reversed.
//
//				f.literals[implication_id] = implication_polarity;  // 0 - if true, 1 - if false, set the literal
//				f.literal_frequency[implication_id] = -1;
//			}
//			// Need to check if satisfied after all the unit implications
//			return Cat::normal;
//			break;
//		default:
//			return Cat::unsatisfied;
//			// Error state
//	}
//
//	// Listen to status
//
//	// if reg4 = 0x1 => No changes, need more decisions
//
//	// if reg4 = 0x4 => Conflict. Start backtracking. Pop literals added in the level.
//	// if reg4 = 0x5 => SAT
//	// if reg4 = 0x6 => Implication Found. Add to list of literals
//
//
//    for (int i = 0; i < f.clauses.size(); i++) {        // iterate over the variables in the clause
//        for (int j = 0; j < f.clauses[i].size(); j++) {
//            // if this is true, then the literal appears with the same polarity
//            // as it is being applied that is, if assigned true, it appears
//            // positive if assigned false, it appears negative, in this clause
//            // hence, the clause has now become true
//            if ((2 * literal_to_apply + value_to_apply) == f.clauses[i][j]) {
//                f.clauses.erase(f.clauses.begin() + i);  // remove the clause from the list
//                i--;                                     // reset iterator
//                if (f.clauses.size() == 0) {             // if all clauses have been removed, the formula is satisfied
//                    return Cat::satisfied;
//                }
//                break;                                             // move to the next clause
//            } else if (f.clauses[i][j] / 2 == literal_to_apply) {  // the literal appears with opposite polarity
//                f.clauses[i].erase(f.clauses[i].begin() + j);      // remove the literal from the clause, as it is false in it
//                j--;                                               // reset the iterator
//                if (f.clauses[i].size() == 0) {                    // if the clause is empty, the formula is unsatisfiable currently
//
//                    return Cat::unsatisfied;
//                }
//                break;  // move to the next clause
//            }
//        }
//    }
//    // if reached here, the function is exiting normally
//    return Cat::normal;
//}

/*
 * function to perform the recursive DPLL on a given formula
 * argument: f - the formula to perform DPLL on
 * return value: int - the return status flag, a member of the Cat enum
 *               Cat::normal - exited normally
 *               Cat::completed - result has been found, exit recursion all the
 * way
 */
int SATSolverDPLL::DPLL(Formula f) {
    // steady_clock::time_point begin = steady_clock::now();

    // int result = unit_propagate(f);  // perform unit propagation on the formula

    // steady_clock::time_point end = steady_clock::now();
    // cout << "Time difference = " << duration_cast<nanoseconds>(end - begin).count() << "[ns]" << endl;

    // if (result == Cat::satisfied) {  // if formula satisfied, show result and return
    //     show_result(f, result);
    //     return Cat::completed;
    // } else if (result == Cat::unsatisfied) {  // if formula not satisfied in this branch, return normally
    //     return Cat::normal;
    // }

    // find the variable with maximum frequency in f, which will be the next to
    // be assigned a value already assigned variables have this field reset to
    // -1 in order to ignore them
    int i = distance(f.literal_frequency.begin(), max_element(f.literal_frequency.begin(), f.literal_frequency.end()));
    // need to apply twice, once true, the other false
    for (int j = 0; j < 2; j++) {
        Formula new_f = f;                    // copy the formula before recursing
        if (new_f.literal_polarity[i] > 0) {  // if the number of literals with positive polarity are greater
            new_f.literals[i] = j;            // assign positive first
        } else {                              // if not
            new_f.literals[i] = (j + 1) % 2;  // assign negative first
        }

        new_f.literal_frequency[i] = -1;                   // reset the frequency to -1 to ignore in the future
        int transform_result = unit_propagate(new_f, i, true);  // apply the change to all the clauses

        if (transform_result == Cat::satisfied) {  // if formula satisfied, show result and return
            show_result(new_f, transform_result);
            return Cat::completed;
        } else if (transform_result == Cat::unsatisfied) {  // if formula not satisfied in this branch, return normally
            continue;
        }

        int dpll_result = DPLL(new_f);  // recursively call DPLL on the new formula

        if (dpll_result == Cat::completed) {  // propagate the result, if completed
            return dpll_result;
        }
    }

    // if the control reaches here, the function has returned normally
    return Cat::normal;
}

/*
 * function to display the result of the solver
 * arguments: f - the formula when it was satisfied or shown to be unsatisfiable
 *            result - the result flag, a member of the Cat enum
 */
void SATSolverDPLL::show_result(Formula &f, int result) {
    if (result == Cat::satisfied)  // if the formula is satisfiable
    {
        cout << "SAT" << endl;
        for (int i = 0; i < f.literals.size(); i++) {
            if (i != 0) {
                cout << " ";
            }
            if (f.literals[i] != -1) {
                cout << pow(-1, f.literals[i]) * (i + 1);
            } else {  // for literals which can take either value, arbitrarily assign them to be true
                cout << (i + 1);
            }
        }
        cout << " 0 \n";
    } else  // if the formula is unsatisfiable
    {
        cout << "UNSAT";
    }
}

/*
 * function to call the solver
 */
void SATSolverDPLL::solve() {
    // Possible that an unit clause exits that automatically satisfies the problem before making decisions
    // int simplify_result = unit_propagate(formula, 0, false);
    // if (simplify_result == Cat::satisfied) {  // if formula satisfied, show result and return
    //     show_result(formula, simplify_result);
    //     return;
    // } else if (simplify_result == Cat::unsatisfied) {  // if formula not satisfied in this branch, return normally
    //     return;
    // }

    int result = DPLL(formula);  // final result of DPLL on the original formula
    // if normal return till the end, then the formula could not be satisfied in
    // any branch, so it is unsatisfiable
    if (result == Cat::normal) {
        show_result(formula,
                    Cat::unsatisfied);  // the argument formula is a dummy
                                        // here, the result is UNSAT
    }
}

int main() {
	init_platform();

//	    volatile uint32_t *reg0 = (volatile uint32_t *) 0x43C00000;
//
//	    volatile uint32_t *reg1 = (volatile uint32_t *) 0x43C00004;
//
//	    volatile uint32_t *reg2 = (volatile uint32_t *) 0x43C00008;
//
//	    volatile uint32_t *reg3 = (volatile uint32_t *) 0x43C0000c;
//
//	    volatile uint32_t *reg4 = (volatile uint32_t *) 0x43C00010;
//
//	    volatile uint32_t *reg5 = (volatile uint32_t *) 0x43C00014;
//
//	    volatile uint32_t *reg6 = (volatile uint32_t *) 0x43C00018;

	    printf("Hello World\n");
	    printf("Successfully ran Hello World application\n");
	    printf("Starting DPLL\n");


    SATSolverDPLL solver;  // create the solver
    solver.initialize();   // initialize
    solver.solve();        // solve
//    return 0;
	    cleanup_platform();
	    return 0;
}
